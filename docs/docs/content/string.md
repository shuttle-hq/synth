Synth's `string` generator type regroups many different useful functionalities, including the ability to generate
sentences from regular expressions, as well as leveraging [Faker][faker] providers to generate valid addresses,
telephone numbers, etc.

## pattern

String values generated by a specified regular expression in the `pattern` key.

#### Example

```json synth
{
  "type": "string",
  "pattern": "I am a (man|woman) with [2-9] friends"
}
```

## uuid

`uuid` generates hyphenated [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).

This generator has no parameters.

#### Example

```json synth
{
  "type": "string",
  "uuid": {}
}
```

## format

`format` allows to format one or more string values by parsing a parametric
format string and processing the specified replacements.

#### Example

```json synth
{
  "type": "string",
  "format": {
    "format": "my name is {name} and my email is {email}",
    "arguments": {
      "name": {
        "type": "string",
        "faker": {
          "generator": "username"
        }
      },
      "email": {
        "type": "string",
        "faker": {
          "generator": "safe_email"
        }
      }
    }
  }
}
```

## faker

Synth has an internal fake data generator that will generate fake data for semantic types such as Names, Addresses, etc.

#### Example

```json synth
{
  "type": "string",
  "faker": {
    "generator": "address"
  }
}
```

Faker offers a variety of different fake data, in different locales and can be leveraged easily from Synth schemas using
the `generator` key.

#### first_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "first_name"
	}
}
```

#### last_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "last_name"
	}
}
```

#### title


```json synth
{
	"type": "string",
	"faker": {
		"generator": "title"
	}
}
```

#### suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "suffix"
	}
}
```

#### name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "name"
	}
}
```

#### name_with_title


```json synth
{
	"type": "string",
	"faker": {
		"generator": "name_with_title"
	}
}
```

#### credit_card


```json synth
{
	"type": "string",
	"faker": {
		"generator": "credit_card"
	}
}
```

#### free_email_provider


```json synth
{
	"type": "string",
	"faker": {
		"generator": "free_email_provider"
	}
}
```

#### domain_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "domain_suffix"
	}
}
```

#### free_email


```json synth
{
	"type": "string",
	"faker": {
		"generator": "free_email"
	}
}
```

#### safe_email


```json synth
{
	"type": "string",
	"faker": {
		"generator": "safe_email"
	}
}
```

#### username


```json synth
{
	"type": "string",
	"faker": {
		"generator": "username"
	}
}
```

#### ipv4


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ipv4"
	}
}
```

#### ipv6


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ipv6"
	}
}
```

#### ip


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ip"
	}
}
```

#### mac_address


```json synth
{
	"type": "string",
	"faker": {
		"generator": "mac_address"
	}
}
```

#### color


```json synth
{
	"type": "string",
	"faker": {
		"generator": "color"
	}
}
```

#### user_agent


```json synth
{
	"type": "string",
	"faker": {
		"generator": "user_agent"
	}
}
```

#### rfc_status_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "rfc_status_code"
	}
}
```

#### valid_status_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "valid_status_code"
	}
}
```

#### company_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "company_suffix"
	}
}
```

#### company_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "company_name"
	}
}
```

#### buzzword


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword"
	}
}
```

#### buzzword_muddle


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword_muddle"
	}
}
```

#### buzzword_tail


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword_tail"
	}
}
```

#### catch_phrase


```json synth
{
	"type": "string",
	"faker": {
		"generator": "catch_phrase"
	}
}
```

#### bs_verb


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_verb"
	}
}
```

#### bs_adj


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_adj"
	}
}
```

#### bs_noun


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_noun"
	}
}
```

#### bs


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs"
	}
}
```

#### profession


```json synth
{
	"type": "string",
	"faker": {
		"generator": "profession"
	}
}
```

#### industry


```json synth
{
	"type": "string",
	"faker": {
		"generator": "industry"
	}
}
```

#### city_prefix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_prefix"
	}
}
```

#### city_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_suffix"
	}
}
```

#### city_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_name"
	}
}
```

#### country_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "country_name"
	}
}
```

#### country_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "country_code"
	}
}
```

#### street_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "street_suffix"
	}
}
```

#### street_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "street_name"
	}
}
```

#### time_zone


```json synth
{
	"type": "string",
	"faker": {
		"generator": "time_zone"
	}
}
```

#### state_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "state_name"
	}
}
```

#### state_abbr


```json synth
{
	"type": "string",
	"faker": {
		"generator": "state_abbr"
	}
}
```

#### secondary_address_type


```json synth
{
	"type": "string",
	"faker": {
		"generator": "secondary_address_type"
	}
}
```

#### secondary_address


```json synth
{
	"type": "string",
	"faker": {
		"generator": "secondary_address"
	}
}
```

#### zip_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "zip_code"
	}
}
```

#### post_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "post_code"
	}
}
```

#### building_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "building_number"
	}
}
```

#### latitude


```json synth
{
	"type": "string",
	"faker": {
		"generator": "latitude"
	}
}
```

#### longitude


```json synth
{
	"type": "string",
	"faker": {
		"generator": "longitude"
	}
}
```

#### phone_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "phone_number"
	}
}
```

#### cell_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "cell_number"
	}
}
```

#### file_path


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_path"
	}
}
```

#### file_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_name"
	}
}
```

#### file_extension


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_extension"
	}
}
```

#### dir_path


```json synth
{
	"type": "string",
	"faker": {
		"generator": "dir_path"
	}
}
```

## serialized

`serialized` is a variant of the `string` generator type which serializes the output of a child generator into a string.

`serialized` has 2 fields,
- `serializer`: The serializer to be used (currently only `json`)
- `content`: The content to be serialized. This can be any valid Synth generator



#### Example

```json synth
{
    "type": "string",
    "serialized": {
        "serializer": "json",
        "content": {
            "type": "object",
            "username": {
                "type": "string",
                "faker": {
                    "generator": "name"
                }
            }
        }
    }
}
```

## truncated

The `truncated` generator truncates the output of it's inner generator to a fixed length.

If the output of its inner generator is less than or equal to the length, it is left untouched.

`truncated` has 2 fields,
- `length`: The number of characters to truncate to. This can be any Synth generator that yields a non-negative Number.
- `content`: The content to be truncated. This can be any Synth generator that yields a String.

#### Example

```json synth
{
  "type": "string",
  "truncated": {
    "content": {
      "type": "string",
      "pattern": "[a-zA-Z0-9]{0, 255}"
    },
    "length": 5
  }
}
```

## sliced

The `sliced` generator takes a character slice of a string. 

The slice format is `[start]:[finish]` and if it fails to parse the original string will be returned.

`sliced` has 2 fields,
- `slice`: A string with a optional start and optional end separated by `:`
- `content`: The content to be sliced. This can be any Synth generator that yields a String.

#### Example

```json synth
{
  "type": "string",
  "sliced": {
    "content": {
      "type": "string",
      "pattern": "[a-zA-Z0-9]{10, 20}"
    },
    "slice": "3:5"
  }
}
```

## constant

The `constant` generator allows you to generate a constant string. Strings that begin with `@` can
also be declared constant instead of being treated as a reference, although you need to use the long-form version:

```json synth
{
  "type": "string",
  "constant": "@foobar"
}
```

Or shorthand notation if you are declaring an object field:

```json synth
{
  "type": "object",
  "name": "bob"
}
```



## categorical

A `categorical` is a variant of the `string` generator type that generates values from a finite set of user-defined
values. You can specify a string as a categorical by using the `"categorical": {...}` key/value pair.

#### Example

```json synth
{
  "type": "string",
  "categorical": {
    "pawn": 8,
    "rook": 2,
    "knight": 2,
    "bishop": 2,
    "queen": 1,
    "king": 1
  }
}
```

The value of the `"categorical"` key must be an object whose:

- keys are the allowed values of the categorical (e.g. `"pawn"`, `"rook"`, etc.),
- values are non-negative integers defining the relative weight of the corresponding variant (e.g. `8`, `2`, etc.).

[faker]: https://github.com/cksac/fake-rs

